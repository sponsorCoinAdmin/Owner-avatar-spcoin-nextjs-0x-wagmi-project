"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ox";
exports.ids = ["vendor-chunks/ox"];
exports.modules = {

/***/ "(ssr)/./node_modules/ox/_cjs/core/BlockOverrides.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/BlockOverrides.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromRpc = fromRpc;\nexports.toRpc = toRpc;\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Withdrawal = __webpack_require__(/*! ./Withdrawal.js */ \"(ssr)/./node_modules/ox/_cjs/core/Withdrawal.js\");\nfunction fromRpc(rpcBlockOverrides) {\n    return {\n        ...(rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),\n        }),\n        ...(rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),\n        }),\n        ...(rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient,\n        }),\n        ...(rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit),\n        }),\n        ...(rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number),\n        }),\n        ...(rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao),\n        }),\n        ...(rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time),\n        }),\n        ...(rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(Withdrawal.fromRpc),\n        }),\n    };\n}\nfunction toRpc(blockOverrides) {\n    return {\n        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {\n            baseFeePerGas: Hex.fromNumber(blockOverrides.baseFeePerGas),\n        }),\n        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {\n            blobBaseFee: Hex.fromNumber(blockOverrides.blobBaseFee),\n        }),\n        ...(typeof blockOverrides.feeRecipient === 'string' && {\n            feeRecipient: blockOverrides.feeRecipient,\n        }),\n        ...(typeof blockOverrides.gasLimit === 'bigint' && {\n            gasLimit: Hex.fromNumber(blockOverrides.gasLimit),\n        }),\n        ...(typeof blockOverrides.number === 'bigint' && {\n            number: Hex.fromNumber(blockOverrides.number),\n        }),\n        ...(typeof blockOverrides.prevRandao === 'bigint' && {\n            prevRandao: Hex.fromNumber(blockOverrides.prevRandao),\n        }),\n        ...(typeof blockOverrides.time === 'bigint' && {\n            time: Hex.fromNumber(blockOverrides.time),\n        }),\n        ...(blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(Withdrawal.toRpc),\n        }),\n    };\n}\n//# sourceMappingURL=BlockOverrides.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0Jsb2NrT3ZlcnJpZGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixhQUFhO0FBQ2IsWUFBWSxtQkFBTyxDQUFDLDBEQUFVO0FBQzlCLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9CbG9ja092ZXJyaWRlcy5qcz8xODNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tUnBjID0gZnJvbVJwYztcbmV4cG9ydHMudG9ScGMgPSB0b1JwYztcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmNvbnN0IFdpdGhkcmF3YWwgPSByZXF1aXJlKFwiLi9XaXRoZHJhd2FsLmpzXCIpO1xuZnVuY3Rpb24gZnJvbVJwYyhycGNCbG9ja092ZXJyaWRlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzICYmIHtcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSAmJiB7XG4gICAgICAgICAgICBibG9iQmFzZUZlZTogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQgJiYge1xuICAgICAgICAgICAgZmVlUmVjaXBpZW50OiBycGNCbG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQsXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuZ2FzTGltaXQgJiYge1xuICAgICAgICAgICAgZ2FzTGltaXQ6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5nYXNMaW1pdCksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMubnVtYmVyICYmIHtcbiAgICAgICAgICAgIG51bWJlcjogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLm51bWJlciksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyAmJiB7XG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMudGltZSAmJiB7XG4gICAgICAgICAgICB0aW1lOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMudGltZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMgJiYge1xuICAgICAgICAgICAgd2l0aGRyYXdhbHM6IHJwY0Jsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzLm1hcChXaXRoZHJhd2FsLmZyb21ScGMpLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9ScGMoYmxvY2tPdmVycmlkZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgYmxvYkJhc2VGZWU6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50ID09PSAnc3RyaW5nJyAmJiB7XG4gICAgICAgICAgICBmZWVSZWNpcGllbnQ6IGJsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGdhc0xpbWl0OiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5nYXNMaW1pdCksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLm51bWJlciA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgbnVtYmVyOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5udW1iZXIpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMudGltZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgdGltZTogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMudGltZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMgJiYge1xuICAgICAgICAgICAgd2l0aGRyYXdhbHM6IGJsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzLm1hcChXaXRoZHJhd2FsLnRvUnBjKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2NrT3ZlcnJpZGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/BlockOverrides.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = exports.SizeOverflowError = exports.InvalidBytesTypeError = exports.InvalidBytesBooleanError = void 0;\nexports.assert = assert;\nexports.concat = concat;\nexports.from = from;\nexports.fromArray = fromArray;\nexports.fromBoolean = fromBoolean;\nexports.fromHex = fromHex;\nexports.fromNumber = fromNumber;\nexports.fromString = fromString;\nexports.isEqual = isEqual;\nexports.padLeft = padLeft;\nexports.padRight = padRight;\nexports.random = random;\nexports.size = size;\nexports.slice = slice;\nexports.toBigInt = toBigInt;\nexports.toBoolean = toBoolean;\nexports.toHex = toHex;\nexports.toNumber = toNumber;\nexports.toString = toString;\nexports.trimLeft = trimLeft;\nexports.trimRight = trimRight;\nexports.validate = validate;\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Json = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_cjs/core/Json.js\");\nconst internal = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/bytes.js\");\nconst internal_hex = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/hex.js\");\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\nfunction assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        internal_hex.assertSize(value, size);\n        hex = Hex.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new Errors.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\nfunction fromNumber(value, options) {\n    const hex = Hex.fromNumber(value, options);\n    return fromHex(hex);\n}\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\nfunction isEqual(bytesA, bytesB) {\n    return (0, utils_1.equalBytes)(bytesA, bytesB);\n}\nfunction padLeft(value, size) {\n    return internal.pad(value, { dir: 'left', size });\n}\nfunction padRight(value, size) {\n    return internal.pad(value, { dir: 'right', size });\n}\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\nfunction size(value) {\n    return value.length;\n}\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        internal.assertEndOffset(value_, start, end);\n    return value_;\n}\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toBigInt(hex, options);\n}\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\nfunction toHex(value, options = {}) {\n    return Hex.fromBytes(value, options);\n}\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toNumber(hex, options);\n}\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\nfunction trimLeft(value) {\n    return internal.trim(value, { dir: 'left' });\n}\nfunction trimRight(value) {\n    return internal.trim(value, { dir: 'right' });\n}\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nclass InvalidBytesBooleanError extends Errors.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\nexports.InvalidBytesBooleanError = InvalidBytesBooleanError;\nclass InvalidBytesTypeError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\nexports.InvalidBytesTypeError = InvalidBytesTypeError;\nclass SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\nexports.SizeOverflowError = SizeOverflowError;\nclass SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\nexports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;\nclass SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\nexports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;\n//# sourceMappingURL=Bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQyxHQUFHLG1DQUFtQyxHQUFHLHlCQUF5QixHQUFHLDZCQUE2QixHQUFHLGdDQUFnQztBQUN4SyxjQUFjO0FBQ2QsY0FBYztBQUNkLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxZQUFZO0FBQ1osYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMsMEZBQThCO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQyxnRUFBYTtBQUNwQyxZQUFZLG1CQUFPLENBQUMsMERBQVU7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDREQUFXO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFxQjtBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlCQUFpQixFQUFFLGlCQUFpQixRQUFRLFVBQVU7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSx5QkFBeUIsMERBQTBELGVBQWUsYUFBYTtBQUMvRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNDQUFzQyxRQUFRLDBCQUEwQixVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0MsdUJBQXVCLDhDQUE4QyxjQUFjLE9BQU8sK0JBQStCLEtBQUs7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQyxpQkFBaUIsNkJBQTZCLEVBQUU7QUFDaEQ7QUFDQSw0QkFBNEIsVUFBVSxLQUFLLDhCQUE4QixXQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9CeXRlcy5qcz8wODM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgPSBleHBvcnRzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciA9IGV4cG9ydHMuU2l6ZU92ZXJmbG93RXJyb3IgPSBleHBvcnRzLkludmFsaWRCeXRlc1R5cGVFcnJvciA9IGV4cG9ydHMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21BcnJheSA9IGZyb21BcnJheTtcbmV4cG9ydHMuZnJvbUJvb2xlYW4gPSBmcm9tQm9vbGVhbjtcbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5leHBvcnRzLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuZXhwb3J0cy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbmV4cG9ydHMuaXNFcXVhbCA9IGlzRXF1YWw7XG5leHBvcnRzLnBhZExlZnQgPSBwYWRMZWZ0O1xuZXhwb3J0cy5wYWRSaWdodCA9IHBhZFJpZ2h0O1xuZXhwb3J0cy5yYW5kb20gPSByYW5kb207XG5leHBvcnRzLnNpemUgPSBzaXplO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlO1xuZXhwb3J0cy50b0JpZ0ludCA9IHRvQmlnSW50O1xuZXhwb3J0cy50b0Jvb2xlYW4gPSB0b0Jvb2xlYW47XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLnRvTnVtYmVyID0gdG9OdW1iZXI7XG5leHBvcnRzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG5leHBvcnRzLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5leHBvcnRzLnRyaW1SaWdodCA9IHRyaW1SaWdodDtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoXCIuL0Vycm9ycy5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmNvbnN0IEpzb24gPSByZXF1aXJlKFwiLi9Kc29uLmpzXCIpO1xuY29uc3QgaW50ZXJuYWwgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9ieXRlcy5qc1wiKTtcbmNvbnN0IGludGVybmFsX2hleCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2hleC5qc1wiKTtcbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKCEoJ0JZVEVTX1BFUl9FTEVNRU5UJyBpbiB2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh2YWx1ZS5CWVRFU19QRVJfRUxFTUVOVCAhPT0gMSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnVWludDhBcnJheScpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xufVxuZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmcm9tSGV4KHZhbHVlKTtcbiAgICByZXR1cm4gZnJvbUFycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb21BcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyB2YWx1ZSA6IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBmcm9tSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGhleCA9IHZhbHVlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGludGVybmFsX2hleC5hc3NlcnRTaXplKHZhbHVlLCBzaXplKTtcbiAgICAgICAgaGV4ID0gSGV4LnBhZFJpZ2h0KHZhbHVlLCBzaXplKTtcbiAgICB9XG4gICAgbGV0IGhleFN0cmluZyA9IGhleC5zbGljZSgyKTtcbiAgICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIpXG4gICAgICAgIGhleFN0cmluZyA9IGAwJHtoZXhTdHJpbmd9YDtcbiAgICBjb25zdCBsZW5ndGggPSBoZXhTdHJpbmcubGVuZ3RoIC8gMjtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBqID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgbmliYmxlTGVmdCA9IGludGVybmFsLmNoYXJDb2RlVG9CYXNlMTYoaGV4U3RyaW5nLmNoYXJDb2RlQXQoaisrKSk7XG4gICAgICAgIGNvbnN0IG5pYmJsZVJpZ2h0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgaWYgKG5pYmJsZUxlZnQgPT09IHVuZGVmaW5lZCB8fCBuaWJibGVSaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcihgSW52YWxpZCBieXRlIHNlcXVlbmNlIChcIiR7aGV4U3RyaW5nW2ogLSAyXX0ke2hleFN0cmluZ1tqIC0gMV19XCIgaW4gXCIke2hleFN0cmluZ31cIikuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXNbaW5kZXhdID0gbmliYmxlTGVmdCAqIDE2ICsgbmliYmxlUmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbU51bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZyb21IZXgoaGV4KTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICByZXR1cm4gcGFkUmlnaHQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBpc0VxdWFsKGJ5dGVzQSwgYnl0ZXNCKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmVxdWFsQnl0ZXMpKGJ5dGVzQSwgYnl0ZXNCKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ2xlZnQnLCBzaXplIH0pO1xufVxuZnVuY3Rpb24gcGFkUmlnaHQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ3JpZ2h0Jywgc2l6ZSB9KTtcbn1cbmZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShsZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xufVxuZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gdmFsdWUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbmZ1bmN0aW9uIHRvQmlnSW50KGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b0JpZ0ludChoZXgsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdG9Cb29sZWFuKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzXyA9IGJ5dGVzO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlc18sIHNpemUpO1xuICAgICAgICBieXRlc18gPSB0cmltTGVmdChieXRlc18pO1xuICAgIH1cbiAgICBpZiAoYnl0ZXNfLmxlbmd0aCA+IDEgfHwgYnl0ZXNfWzBdID4gMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcihieXRlc18pO1xuICAgIHJldHVybiBCb29sZWFuKGJ5dGVzX1swXSk7XG59XG5mdW5jdGlvbiB0b0hleCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXModmFsdWUsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdG9OdW1iZXIoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gSGV4LnRvTnVtYmVyKGhleCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlc18gPSBieXRlcztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXNfLCBzaXplKTtcbiAgICAgICAgYnl0ZXNfID0gdHJpbVJpZ2h0KGJ5dGVzXyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShieXRlc18pO1xufVxuZnVuY3Rpb24gdHJpbUxlZnQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdsZWZ0JyB9KTtcbn1cbmZ1bmN0aW9uIHRyaW1SaWdodCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ3JpZ2h0JyB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGBCeXRlcyB2YWx1ZSBcXGAke2J5dGVzfVxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yID0gSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yO1xuY2xhc3MgSW52YWxpZEJ5dGVzVHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpzb24uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlfVxcYCBvZiB0eXBlIFxcYCR7dHlwZW9mIHZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIEJ5dGVzIHZhbHVlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydCeXRlcyB2YWx1ZXMgbXVzdCBiZSBvZiB0eXBlIGBCeXRlc2AuJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuSW52YWxpZEJ5dGVzVHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRCeXRlc1R5cGVFcnJvciA9IEludmFsaWRCeXRlc1R5cGVFcnJvcjtcbmNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNpemVPdmVyZmxvd0Vycm9yID0gU2l6ZU92ZXJmbG93RXJyb3I7XG5jbGFzcyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09ICdzdGFydCcgPyAnc3RhcnRpbmcnIDogJ2VuZGluZyd9IGF0IG9mZnNldCBcXGAke29mZnNldH1cXGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogXFxgJHtzaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yID0gU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yO1xuY2xhc3MgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplLCB0YXJnZXRTaXplLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfSBzaXplIChcXGAke3NpemV9XFxgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoXFxgJHt0YXJnZXRTaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yID0gU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseError = void 0;\nconst errors_js_1 = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/errors.js\");\nclass BaseError extends Error {\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = 'https://oxlib.sh';\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: `ox@${(0, errors_js_1.getVersion)()}`\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nexports.BaseError = BaseError;\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQXNCO0FBQ2xEO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9FcnJvcnMuanM/MmE3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUVycm9yID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9lcnJvcnMuanNcIik7XG5jbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc2hvcnRNZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlLmRldGFpbHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRldGFpbHM7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2Uuc2hvcnRNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZT8ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGV0YWlscztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgZG9jc1BhdGggPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZG9jc1BhdGggfHwgb3B0aW9ucy5kb2NzUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRvY3NQYXRoO1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBkb2NzQmFzZVVybCA9ICdodHRwczovL294bGliLnNoJztcbiAgICAgICAgY29uc3QgZG9jcyA9IGAke2RvY3NCYXNlVXJsfSR7ZG9jc1BhdGggPz8gJyd9YDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm1ldGFNZXNzYWdlcyA/IFsnJywgLi4ub3B0aW9ucy5tZXRhTWVzc2FnZXNdIDogW10pLFxuICAgICAgICAgICAgLi4uKGRldGFpbHMgfHwgZG9jc1BhdGhcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPyBgRGV0YWlsczogJHtkZXRhaWxzfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGRvY3NQYXRoID8gYFNlZTogJHtkb2NzfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMuY2F1c2UgPyB7IGNhdXNlOiBvcHRpb25zLmNhdXNlIH0gOiB1bmRlZmluZWQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1BhdGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hvcnRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCYXNlRXJyb3InXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBgb3hAJHsoMCwgZXJyb3JzX2pzXzEuZ2V0VmVyc2lvbikoKX1gXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgdGhpcy5kb2NzID0gZG9jcztcbiAgICAgICAgdGhpcy5kb2NzUGF0aCA9IGRvY3NQYXRoO1xuICAgICAgICB0aGlzLnNob3J0TWVzc2FnZSA9IHNob3J0TWVzc2FnZTtcbiAgICB9XG4gICAgd2Fsayhmbikge1xuICAgICAgICByZXR1cm4gd2Fsayh0aGlzLCBmbik7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlRXJyb3IgPSBCYXNlRXJyb3I7XG5mdW5jdGlvbiB3YWxrKGVyciwgZm4pIHtcbiAgICBpZiAoZm4/LihlcnIpKVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgJ2NhdXNlJyBpbiBlcnIgJiYgZXJyLmNhdXNlKVxuICAgICAgICByZXR1cm4gd2FsayhlcnIuY2F1c2UsIGZuKTtcbiAgICByZXR1cm4gZm4gPyBudWxsIDogZXJyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_cjs/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = exports.SizeOverflowError = exports.InvalidLengthError = exports.InvalidHexValueError = exports.InvalidHexTypeError = exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = void 0;\nexports.assert = assert;\nexports.concat = concat;\nexports.from = from;\nexports.fromBoolean = fromBoolean;\nexports.fromBytes = fromBytes;\nexports.fromNumber = fromNumber;\nexports.fromString = fromString;\nexports.isEqual = isEqual;\nexports.padLeft = padLeft;\nexports.padRight = padRight;\nexports.random = random;\nexports.slice = slice;\nexports.size = size;\nexports.trimLeft = trimLeft;\nexports.trimRight = trimRight;\nexports.toBigInt = toBigInt;\nexports.toBoolean = toBoolean;\nexports.toBytes = toBytes;\nexports.toNumber = toNumber;\nexports.toString = toString;\nexports.validate = validate;\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Json = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_cjs/core/Json.js\");\nconst internal_bytes = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/bytes.js\");\nconst internal = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/hex.js\");\nconst encoder = new TextEncoder();\nconst hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        internal.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\nfunction fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        internal.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\nfunction isEqual(hexA, hexB) {\n    return (0, utils_1.equalBytes)(Bytes.fromHex(hexA), Bytes.fromHex(hexB));\n}\nfunction padLeft(value, size) {\n    return internal.pad(value, { dir: 'left', size });\n}\nfunction padRight(value, size) {\n    return internal.pad(value, { dir: 'right', size });\n}\nfunction random(length) {\n    return fromBytes(Bytes.random(length));\n}\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        internal.assertEndOffset(value_, start, end);\n    return value_;\n}\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\nfunction trimLeft(value) {\n    return internal.trim(value, { dir: 'left' });\n}\nfunction trimRight(value) {\n    return internal.trim(value, { dir: 'right' });\n}\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        internal.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\nfunction toBoolean(hex, options = {}) {\n    if (options.size)\n        internal.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\nfunction toBytes(hex, options = {}) {\n    return Bytes.fromHex(hex, options);\n}\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = Bytes.fromHex(hex);\n    if (size) {\n        internal_bytes.assertSize(bytes, size);\n        bytes = Bytes.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nclass IntegerOutOfRangeError extends Errors.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\nexports.IntegerOutOfRangeError = IntegerOutOfRangeError;\nclass InvalidHexBooleanError extends Errors.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\nexports.InvalidHexBooleanError = InvalidHexBooleanError;\nclass InvalidHexTypeError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\nexports.InvalidHexTypeError = InvalidHexTypeError;\nclass InvalidHexValueError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\nexports.InvalidHexValueError = InvalidHexValueError;\nclass InvalidLengthError extends Errors.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\nexports.InvalidLengthError = InvalidLengthError;\nclass SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\nexports.SizeOverflowError = SizeOverflowError;\nclass SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\nexports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;\nclass SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\nexports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;\n//# sourceMappingURL=Hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0hleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyxtQ0FBbUMsR0FBRyx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDalEsY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZO0FBQ1osbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxhQUFhO0FBQ2IsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMsMEZBQThCO0FBQ3RELGNBQWMsbUJBQU8sQ0FBQyw4REFBWTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsZ0VBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDREQUFXO0FBQ2hDLHVCQUF1QixtQkFBTyxDQUFDLGdGQUFxQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDNUM7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QyxtQ0FBbUM7QUFDbkMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLG9CQUFvQixrQkFBa0I7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QVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQyxpQkFBaUIsNkJBQTZCLEVBQUU7QUFDaEQ7QUFDQSw0QkFBNEIsVUFBVSxLQUFLLDhCQUE4QixXQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9IZXguanM/ZDMzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yID0gZXhwb3J0cy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgPSBleHBvcnRzLlNpemVPdmVyZmxvd0Vycm9yID0gZXhwb3J0cy5JbnZhbGlkTGVuZ3RoRXJyb3IgPSBleHBvcnRzLkludmFsaWRIZXhWYWx1ZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkSGV4VHlwZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yID0gZXhwb3J0cy5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21Cb29sZWFuID0gZnJvbUJvb2xlYW47XG5leHBvcnRzLmZyb21CeXRlcyA9IGZyb21CeXRlcztcbmV4cG9ydHMuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XG5leHBvcnRzLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuZXhwb3J0cy5pc0VxdWFsID0gaXNFcXVhbDtcbmV4cG9ydHMucGFkTGVmdCA9IHBhZExlZnQ7XG5leHBvcnRzLnBhZFJpZ2h0ID0gcGFkUmlnaHQ7XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMuc2l6ZSA9IHNpemU7XG5leHBvcnRzLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5leHBvcnRzLnRyaW1SaWdodCA9IHRyaW1SaWdodDtcbmV4cG9ydHMudG9CaWdJbnQgPSB0b0JpZ0ludDtcbmV4cG9ydHMudG9Cb29sZWFuID0gdG9Cb29sZWFuO1xuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbmV4cG9ydHMudG9OdW1iZXIgPSB0b051bWJlcjtcbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiKTtcbmNvbnN0IEJ5dGVzID0gcmVxdWlyZShcIi4vQnl0ZXMuanNcIik7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi9FcnJvcnMuanNcIik7XG5jb25zdCBKc29uID0gcmVxdWlyZShcIi4vSnNvbi5qc1wiKTtcbmNvbnN0IGludGVybmFsX2J5dGVzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYnl0ZXMuanNcIik7XG5jb25zdCBpbnRlcm5hbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2hleC5qc1wiKTtcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfdiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFR5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoIS9eMHhbMC05YS1mQS1GXSokLy50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aCgnMHgnKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhWYWx1ZUVycm9yKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNvbmNhdCguLi52YWx1ZXMpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgucmVwbGFjZSgnMHgnLCAnJyksICcnKX1gO1xufVxuZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXModmFsdWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoZXggPSBgMHgke051bWJlcih2YWx1ZSl9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIGZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgIHN0cmluZyArPSBoZXhlc1t2YWx1ZVtpXV07XG4gICAgY29uc3QgaGV4ID0gYDB4JHtzdHJpbmd9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRSaWdodChoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZV8gPSBCaWdJbnQodmFsdWUpO1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2lnbmVkKVxuICAgICAgICAgICAgbWF4VmFsdWUgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuIC0gMW4pKSAtIDFuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXhWYWx1ZSA9IDJuICoqIChCaWdJbnQoc2l6ZSkgKiA4bikgLSAxbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXhWYWx1ZSA9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG4gICAgfVxuICAgIGNvbnN0IG1pblZhbHVlID0gdHlwZW9mIG1heFZhbHVlID09PSAnYmlnaW50JyAmJiBzaWduZWQgPyAtbWF4VmFsdWUgLSAxbiA6IDA7XG4gICAgaWYgKChtYXhWYWx1ZSAmJiB2YWx1ZV8gPiBtYXhWYWx1ZSkgfHwgdmFsdWVfIDwgbWluVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/ICduJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgSW50ZWdlck91dE9mUmFuZ2VFcnJvcih7XG4gICAgICAgICAgICBtYXg6IG1heFZhbHVlID8gYCR7bWF4VmFsdWV9JHtzdWZmaXh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1pbjogYCR7bWluVmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICB2YWx1ZTogYCR7dmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gKHNpZ25lZCAmJiB2YWx1ZV8gPCAwID8gKDFuIDw8IEJpZ0ludChzaXplICogOCkpICsgQmlnSW50KHZhbHVlXykgOiB2YWx1ZV8pLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ1ZhbHVlfWA7XG4gICAgaWYgKHNpemUpXG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgc2l6ZSk7XG4gICAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBmcm9tQnl0ZXMoZW5jb2Rlci5lbmNvZGUodmFsdWUpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWwoaGV4QSwgaGV4Qikge1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5lcXVhbEJ5dGVzKShCeXRlcy5mcm9tSGV4KGhleEEpLCBCeXRlcy5mcm9tSGV4KGhleEIpKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ2xlZnQnLCBzaXplIH0pO1xufVxuZnVuY3Rpb24gcGFkUmlnaHQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ3JpZ2h0Jywgc2l6ZSB9KTtcbn1cbmZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKEJ5dGVzLnJhbmRvbShsZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCB9ID0gb3B0aW9ucztcbiAgICBpbnRlcm5hbC5hc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpO1xuICAgIGNvbnN0IHZhbHVlXyA9IGAweCR7dmFsdWVcbiAgICAgICAgLnJlcGxhY2UoJzB4JywgJycpXG4gICAgICAgIC5zbGljZSgoc3RhcnQgPz8gMCkgKiAyLCAoZW5kID8/IHZhbHVlLmxlbmd0aCkgKiAyKX1gO1xuICAgIGlmIChzdHJpY3QpXG4gICAgICAgIGludGVybmFsLmFzc2VydEVuZE9mZnNldCh2YWx1ZV8sIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiB2YWx1ZV87XG59XG5mdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbn1cbmZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG5mdW5jdGlvbiB0cmltUmlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdyaWdodCcgfSk7XG59XG5mdW5jdGlvbiB0b0JpZ0ludChoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkIH0gPSBvcHRpb25zO1xuICAgIGlmIChvcHRpb25zLnNpemUpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KGhleCk7XG4gICAgaWYgKCFzaWduZWQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBzaXplID0gKGhleC5sZW5ndGggLSAyKSAvIDI7XG4gICAgY29uc3QgbWF4X3Vuc2lnbmVkID0gKDFuIDw8IChCaWdJbnQoc2l6ZSkgKiA4bikpIC0gMW47XG4gICAgY29uc3QgbWF4X3NpZ25lZCA9IG1heF91bnNpZ25lZCA+PiAxbjtcbiAgICBpZiAodmFsdWUgPD0gbWF4X3NpZ25lZClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSAtIG1heF91bnNpZ25lZCAtIDFuO1xufVxuZnVuY3Rpb24gdG9Cb29sZWFuKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgY29uc3QgaGV4XyA9IHRyaW1MZWZ0KGhleCk7XG4gICAgaWYgKGhleF8gPT09ICcweCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaGV4XyA9PT0gJzB4MScpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHRocm93IG5ldyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yKGhleCk7XG59XG5mdW5jdGlvbiB0b0J5dGVzKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgoaGV4LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHRvTnVtYmVyKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduZWQsIHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFzaWduZWQgJiYgIXNpemUpXG4gICAgICAgIHJldHVybiBOdW1iZXIoaGV4KTtcbiAgICByZXR1cm4gTnVtYmVyKHRvQmlnSW50KGhleCwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gdG9TdHJpbmcoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuZnJvbUhleChoZXgpO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGludGVybmFsX2J5dGVzLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICBieXRlcyA9IEJ5dGVzLnRyaW1SaWdodChieXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlLCB7IHN0cmljdCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEludGVnZXJPdXRPZlJhbmdlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1heCwgbWluLCBzaWduZWQsIHNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBOdW1iZXIgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGluIHNhZmUke3NpemUgPyBgICR7c2l6ZSAqIDh9LWJpdGAgOiAnJ30ke3NpZ25lZCA/ICcgc2lnbmVkJyA6ICcgdW5zaWduZWQnfSBpbnRlZ2VyIHJhbmdlICR7bWF4ID8gYChcXGAke21pbn1cXGAgdG8gXFxgJHttYXh9XFxgKWAgOiBgKGFib3ZlIFxcYCR7bWlufVxcYClgfWApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZWdlck91dE9mUmFuZ2VFcnJvciA9IEludGVnZXJPdXRPZlJhbmdlRXJyb3I7XG5jbGFzcyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaGV4KSB7XG4gICAgICAgIHN1cGVyKGBIZXggdmFsdWUgXFxgXCIke2hleH1cIlxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgaGV4IHZhbHVlIG11c3QgYmUgYFwiMHgwXCJgIChmYWxzZSkgb3IgYFwiMHgxXCJgICh0cnVlKS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleEJvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yID0gSW52YWxpZEhleEJvb2xlYW5FcnJvcjtcbmNsYXNzIEludmFsaWRIZXhUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0hleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4JHtzdHJpbmd9XCJgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRIZXhUeXBlRXJyb3IgPSBJbnZhbGlkSGV4VHlwZUVycm9yO1xuY2xhc3MgSW52YWxpZEhleFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0hleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhWYWx1ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRIZXhWYWx1ZUVycm9yID0gSW52YWxpZEhleFZhbHVlRXJyb3I7XG5jbGFzcyBJbnZhbGlkTGVuZ3RoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgSGV4IHZhbHVlIFxcYFwiJHt2YWx1ZX1cIlxcYCBpcyBhbiBvZGQgbGVuZ3RoICgke3ZhbHVlLmxlbmd0aCAtIDJ9IG5pYmJsZXMpLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydJdCBtdXN0IGJlIGFuIGV2ZW4gbGVuZ3RoLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkTGVuZ3RoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZExlbmd0aEVycm9yID0gSW52YWxpZExlbmd0aEVycm9yO1xuY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNpemVPdmVyZmxvd0Vycm9yID0gU2l6ZU92ZXJmbG93RXJyb3I7XG5jbGFzcyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09ICdzdGFydCcgPyAnc3RhcnRpbmcnIDogJ2VuZGluZyd9IGF0IG9mZnNldCBcXGAke29mZnNldH1cXGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogXFxgJHtzaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciA9IFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcjtcbmNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2l6ZSwgdGFyZ2V0U2l6ZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZVxuICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxgJHtzaXplfVxcYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKFxcYCR7dGFyZ2V0U2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgPSBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_cjs/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = parse;\nexports.stringify = stringify;\nconst bigIntSuffix = '#__bigint';\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0pzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY29ubmVjdGtpdC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2NvcmUvSnNvbi5qcz81ZDc0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5jb25zdCBiaWdJbnRTdWZmaXggPSAnI19fYmlnaW50JztcbmZ1bmN0aW9uIHBhcnNlKHN0cmluZywgcmV2aXZlcikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZywgKGtleSwgdmFsdWVfKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVfO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aChiaWdJbnRTdWZmaXgpKVxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZS5zbGljZSgwLCAtYmlnSW50U3VmZml4Lmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyByZXZpdmVyKGtleSwgdmFsdWUpIDogdmFsdWU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlcihrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIGJpZ0ludFN1ZmZpeDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIHNwYWNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUpzb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Withdrawal.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_cjs/core/Withdrawal.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromRpc = fromRpc;\nexports.toRpc = toRpc;\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nfunction fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex),\n    };\n}\nfunction toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: Hex.fromNumber(withdrawal.amount),\n        index: Hex.fromNumber(withdrawal.index),\n        validatorIndex: Hex.fromNumber(withdrawal.validatorIndex),\n    };\n}\n//# sourceMappingURL=Withdrawal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL1dpdGhkcmF3YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGFBQWE7QUFDYixZQUFZLG1CQUFPLENBQUMsMERBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9XaXRoZHJhd2FsLmpzP2Y2N2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21ScGMgPSBmcm9tUnBjO1xuZXhwb3J0cy50b1JwYyA9IHRvUnBjO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4vSGV4LmpzXCIpO1xuZnVuY3Rpb24gZnJvbVJwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ud2l0aGRyYXdhbCxcbiAgICAgICAgYW1vdW50OiBCaWdJbnQod2l0aGRyYXdhbC5hbW91bnQpLFxuICAgICAgICBpbmRleDogTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogTnVtYmVyKHdpdGhkcmF3YWwudmFsaWRhdG9ySW5kZXgpLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1JwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogd2l0aGRyYXdhbC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuYW1vdW50KSxcbiAgICAgICAgaW5kZXg6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhkcmF3YWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Withdrawal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.charCodeMap = void 0;\nexports.assertSize = assertSize;\nexports.assertStartOffset = assertStartOffset;\nexports.assertEndOffset = assertEndOffset;\nexports.charCodeToBase16 = charCodeToBase16;\nexports.pad = pad;\nexports.trim = trim;\nconst Bytes = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nfunction assertSize(bytes, size_) {\n    if (Bytes.size(bytes) > size_)\n        throw new Bytes.SizeOverflowError({\n            givenSize: Bytes.size(bytes),\n            maxSize: size_,\n        });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: Bytes.size(value),\n        });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        Bytes.size(value) !== end - start) {\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: Bytes.size(value),\n        });\n    }\n}\nexports.charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\nfunction charCodeToBase16(char) {\n    if (char >= exports.charCodeMap.zero && char <= exports.charCodeMap.nine)\n        return char - exports.charCodeMap.zero;\n    if (char >= exports.charCodeMap.A && char <= exports.charCodeMap.F)\n        return char - (exports.charCodeMap.A - 10);\n    if (char >= exports.charCodeMap.a && char <= exports.charCodeMap.f)\n        return char - (exports.charCodeMap.a - 10);\n    return undefined;\n}\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new Bytes.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsV0FBVztBQUNYLFlBQVk7QUFDWixjQUFjLG1CQUFPLENBQUMsK0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNvbm5lY3RraXQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2J5dGVzLmpzP2ZkOTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoYXJDb2RlTWFwID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnRTaXplID0gYXNzZXJ0U2l6ZTtcbmV4cG9ydHMuYXNzZXJ0U3RhcnRPZmZzZXQgPSBhc3NlcnRTdGFydE9mZnNldDtcbmV4cG9ydHMuYXNzZXJ0RW5kT2Zmc2V0ID0gYXNzZXJ0RW5kT2Zmc2V0O1xuZXhwb3J0cy5jaGFyQ29kZVRvQmFzZTE2ID0gY2hhckNvZGVUb0Jhc2UxNjtcbmV4cG9ydHMucGFkID0gcGFkO1xuZXhwb3J0cy50cmltID0gdHJpbTtcbmNvbnN0IEJ5dGVzID0gcmVxdWlyZShcIi4uL0J5dGVzLmpzXCIpO1xuZnVuY3Rpb24gYXNzZXJ0U2l6ZShieXRlcywgc2l6ZV8pIHtcbiAgICBpZiAoQnl0ZXMuc2l6ZShieXRlcykgPiBzaXplXylcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNpemVPdmVyZmxvd0Vycm9yKHtcbiAgICAgICAgICAgIGdpdmVuU2l6ZTogQnl0ZXMuc2l6ZShieXRlcyksXG4gICAgICAgICAgICBtYXhTaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJiBzdGFydCA+IDAgJiYgc3RhcnQgPiBCeXRlcy5zaXplKHZhbHVlKSAtIDEpXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgQnl0ZXMuc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBlbmQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGFyQ29kZU1hcCA9IHtcbiAgICB6ZXJvOiA0OCxcbiAgICBuaW5lOiA1NyxcbiAgICBBOiA2NSxcbiAgICBGOiA3MCxcbiAgICBhOiA5NyxcbiAgICBmOiAxMDIsXG59O1xuZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gZXhwb3J0cy5jaGFyQ29kZU1hcC56ZXJvICYmIGNoYXIgPD0gZXhwb3J0cy5jaGFyQ29kZU1hcC5uaW5lKVxuICAgICAgICByZXR1cm4gY2hhciAtIGV4cG9ydHMuY2hhckNvZGVNYXAuemVybztcbiAgICBpZiAoY2hhciA+PSBleHBvcnRzLmNoYXJDb2RlTWFwLkEgJiYgY2hhciA8PSBleHBvcnRzLmNoYXJDb2RlTWFwLkYpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGV4cG9ydHMuY2hhckNvZGVNYXAuQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBleHBvcnRzLmNoYXJDb2RlTWFwLmEgJiYgY2hhciA8PSBleHBvcnRzLmNoYXJDb2RlTWFwLmYpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGV4cG9ydHMuY2hhckNvZGVNYXAuYSAtIDEwKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcGFkKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciwgc2l6ZSA9IDMyIH0gPSBvcHRpb25zO1xuICAgIGlmIChzaXplID09PSAwKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHNpemUpXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogYnl0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgdGFyZ2V0U2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIHR5cGU6ICdCeXRlcycsXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHBhZGRlZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFkRW5kID0gZGlyID09PSAncmlnaHQnO1xuICAgICAgICBwYWRkZWRCeXRlc1twYWRFbmQgPyBpIDogc2l6ZSAtIGkgLSAxXSA9XG4gICAgICAgICAgICBieXRlc1twYWRFbmQgPyBpIDogYnl0ZXMubGVuZ3RoIC0gaSAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gcGFkZGVkQnl0ZXM7XG59XG5mdW5jdGlvbiB0cmltKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciA9ICdsZWZ0JyB9ID0gb3B0aW9ucztcbiAgICBsZXQgZGF0YSA9IHZhbHVlO1xuICAgIGxldCBzbGljZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtkaXIgPT09ICdsZWZ0JyA/IGkgOiBkYXRhLmxlbmd0aCAtIGkgLSAxXS50b1N0cmluZygpID09PSAnMCcpXG4gICAgICAgICAgICBzbGljZUxlbmd0aCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZGF0YSA9XG4gICAgICAgIGRpciA9PT0gJ2xlZnQnXG4gICAgICAgICAgICA/IGRhdGEuc2xpY2Uoc2xpY2VMZW5ndGgpXG4gICAgICAgICAgICA6IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBzbGljZUxlbmd0aCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUrl = getUrl;\nexports.getVersion = getVersion;\nexports.prettyPrint = prettyPrint;\nconst version_js_1 = __webpack_require__(/*! ../version.js */ \"(ssr)/./node_modules/ox/_cjs/core/version.js\");\nfunction getUrl(url) {\n    return url;\n}\nfunction getVersion() {\n    return version_js_1.version;\n}\nfunction prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUIsbUJBQU8sQ0FBQyxtRUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxHQUFHLElBQUksMkJBQTJCLEVBQUUsTUFBTTtBQUM5RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY29ubmVjdGtpdC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2NvcmUvaW50ZXJuYWwvZXJyb3JzLmpzP2I2YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFVybCA9IGdldFVybDtcbmV4cG9ydHMuZ2V0VmVyc2lvbiA9IGdldFZlcnNpb247XG5leHBvcnRzLnByZXR0eVByaW50ID0gcHJldHR5UHJpbnQ7XG5jb25zdCB2ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vdmVyc2lvbi5qc1wiKTtcbmZ1bmN0aW9uIGdldFVybCh1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHtcbiAgICByZXR1cm4gdmVyc2lvbl9qc18xLnZlcnNpb247XG59XG5mdW5jdGlvbiBwcmV0dHlQcmludChhcmdzKSB7XG4gICAgaWYgKCFhcmdzKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGFyZ3MpXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IGVudHJpZXMucmVkdWNlKChhY2MsIFtrZXldKSA9PiBNYXRoLm1heChhY2MsIGtleS5sZW5ndGgpLCAwKTtcbiAgICByZXR1cm4gZW50cmllc1xuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAgICR7YCR7a2V5fTpgLnBhZEVuZChtYXhMZW5ndGggKyAxKX0gICR7dmFsdWV9YClcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertSize = assertSize;\nexports.assertStartOffset = assertStartOffset;\nexports.assertEndOffset = assertEndOffset;\nexports.pad = pad;\nexports.trim = trim;\nconst Hex = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nfunction assertSize(hex, size_) {\n    if (Hex.size(hex) > size_)\n        throw new Hex.SizeOverflowError({\n            givenSize: Hex.size(hex),\n            maxSize: size_,\n        });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1)\n        throw new Hex.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: Hex.size(value),\n        });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        Hex.size(value) !== end - start) {\n        throw new Hex.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: Hex.size(value),\n        });\n    }\n}\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new Hex.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2hleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixXQUFXO0FBQ1gsWUFBWTtBQUNaLFlBQVksbUJBQU8sQ0FBQywyREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLDREQUE0RDtBQUM1RTtBQUNBLGlDQUFpQztBQUNqQyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekIsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9oZXguanM/MzExMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0U2l6ZSA9IGFzc2VydFNpemU7XG5leHBvcnRzLmFzc2VydFN0YXJ0T2Zmc2V0ID0gYXNzZXJ0U3RhcnRPZmZzZXQ7XG5leHBvcnRzLmFzc2VydEVuZE9mZnNldCA9IGFzc2VydEVuZE9mZnNldDtcbmV4cG9ydHMucGFkID0gcGFkO1xuZXhwb3J0cy50cmltID0gdHJpbTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuLi9IZXguanNcIik7XG5mdW5jdGlvbiBhc3NlcnRTaXplKGhleCwgc2l6ZV8pIHtcbiAgICBpZiAoSGV4LnNpemUoaGV4KSA+IHNpemVfKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNpemVPdmVyZmxvd0Vycm9yKHtcbiAgICAgICAgICAgIGdpdmVuU2l6ZTogSGV4LnNpemUoaGV4KSxcbiAgICAgICAgICAgIG1heFNpemU6IHNpemVfLFxuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IEhleC5zaXplKHZhbHVlKSAtIDEpXG4gICAgICAgIHRocm93IG5ldyBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgICAgICAgIHNpemU6IEhleC5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBIZXguc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWQoaGV4Xywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGhleF87XG4gICAgY29uc3QgaGV4ID0gaGV4Xy5yZXBsYWNlKCcweCcsICcnKTtcbiAgICBpZiAoaGV4Lmxlbmd0aCA+IHNpemUgKiAyKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcih7XG4gICAgICAgICAgICBzaXplOiBNYXRoLmNlaWwoaGV4Lmxlbmd0aCAvIDIpLFxuICAgICAgICAgICAgdGFyZ2V0U2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIHR5cGU6ICdIZXgnLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4gYDB4JHtoZXhbZGlyID09PSAncmlnaHQnID8gJ3BhZEVuZCcgOiAncGFkU3RhcnQnXShzaXplICogMiwgJzAnKX1gO1xufVxuZnVuY3Rpb24gdHJpbSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIgPSAnbGVmdCcgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGRhdGEgPSB2YWx1ZS5yZXBsYWNlKCcweCcsICcnKTtcbiAgICBsZXQgc2xpY2VMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbZGlyID09PSAnbGVmdCcgPyBpIDogZGF0YS5sZW5ndGggLSBpIC0gMV0udG9TdHJpbmcoKSA9PT0gJzAnKVxuICAgICAgICAgICAgc2xpY2VMZW5ndGgrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRhdGEgPVxuICAgICAgICBkaXIgPT09ICdsZWZ0J1xuICAgICAgICAgICAgPyBkYXRhLnNsaWNlKHNsaWNlTGVuZ3RoKVxuICAgICAgICAgICAgOiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gc2xpY2VMZW5ndGgpO1xuICAgIGlmIChkYXRhID09PSAnMCcpXG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIGlmIChkaXIgPT09ICdyaWdodCcgJiYgZGF0YS5sZW5ndGggJSAyID09PSAxKVxuICAgICAgICByZXR1cm4gYDB4JHtkYXRhfTBgO1xuICAgIHJldHVybiBgMHgke2RhdGF9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_cjs/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = '0.1.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS92ZXJzaW9uLmpzPzM3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSAnMC4xLjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidBytesTypeError: () => (/* binding */ InvalidBytesTypeError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n\n\n\n\n\n\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nfunction assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize(value, size);\n        hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromNumber(value, options) {\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nfunction isEqual(bytesA, bytesB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.equalBytes)(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padLeft(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padRight(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nfunction size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value, options = {}) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimLeft(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimRight(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nclass InvalidBytesBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nclass InvalidBytesTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNwQjtBQUNOO0FBQ0U7QUFDYztBQUNFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7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Q3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsaURBQWdCO0FBQ2pFLGtCQUFrQix5QkFBeUI7QUFDM0MsaUJBQWlCLDZCQUE2QixFQUFFO0FBQ2hEO0FBQ0EsNEJBQTRCLFVBQVUsS0FBSyw4QkFBOEIsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CeXRlcy5qcz83MTVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9ieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9oZXggZnJvbSAnLi9pbnRlcm5hbC9oZXguanMnO1xuY29uc3QgZGVjb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8qKlxuICogQXNzZXJ0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IEJ5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYFVpbnQ4QXJyYXlgLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAoISgnQllURVNfUEVSX0VMRU1FTlQnIGluIHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSAxIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdVaW50OEFycmF5JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBieXRlcyA9IEJ5dGVzLmNvbmNhdChcbiAqICAgQnl0ZXMuZnJvbShbMV0pLFxuICogICBCeXRlcy5mcm9tKFs2OV0pLFxuICogICBCeXRlcy5mcm9tKFs0MjAsIDY5XSksXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsgMSwgNjksIDQyMCwgNjkgXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIENvbmNhdGVuYXRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBmcm9tIGEgYFVpbnQ4QXJyYXlgLCBhIGhleCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHVuc2lnbmVkIDgtYml0IGludGVnZXJzLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEJ5dGVzLmZyb21Cb29sZWFuYFxuICpcbiAqIC0gYEJ5dGVzLmZyb21TdHJpbmdgXG4gKlxuICogLSBgQnl0ZXMuZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbShbMjU1LCAxMjQsIDUsIDRdKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzIyMiwgMTczLCAxOTAsIDIzOV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgIHJldHVybiBmcm9tQXJyYXkodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VycyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tQXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21Cb29sZWFuKHRydWUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBCb29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgaGV4ID0gdmFsdWU7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfaGV4LmFzc2VydFNpemUodmFsdWUsIHNpemUpO1xuICAgICAgICBoZXggPSBIZXgucGFkUmlnaHQodmFsdWUsIHNpemUpO1xuICAgIH1cbiAgICBsZXQgaGV4U3RyaW5nID0gaGV4LnNsaWNlKDIpO1xuICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMilcbiAgICAgICAgaGV4U3RyaW5nID0gYDAke2hleFN0cmluZ31gO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhleFN0cmluZy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGogPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBuaWJibGVMZWZ0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgY29uc3QgbmliYmxlUmlnaHQgPSBpbnRlcm5hbC5jaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgICAgICBpZiAobmliYmxlTGVmdCA9PT0gdW5kZWZpbmVkIHx8IG5pYmJsZVJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJ5dGUgc2VxdWVuY2UgKFwiJHtoZXhTdHJpbmdbaiAtIDJdfSR7aGV4U3RyaW5nW2ogLSAxXX1cIiBpbiBcIiR7aGV4U3RyaW5nfVwiKS5gKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1tpbmRleF0gPSBuaWJibGVMZWZ0ICogMTYgKyBuaWJibGVSaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21OdW1iZXIoNDIwKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMTY0XSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbU51bWJlcig0MjAsIHsgc2l6ZTogNCB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMSwgMTY0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE51bWJlciB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBFbmNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmcm9tSGV4KGhleCk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gd29ybGQhJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyB3b3JsZCEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICByZXR1cm4gcGFkUmlnaHQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5pc0VxdWFsKEJ5dGVzLmZyb20oWzFdKSwgQnl0ZXMuZnJvbShbMV0pKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEJ5dGVzLmlzRXF1YWwoQnl0ZXMuZnJvbShbMV0pLCBCeXRlcy5mcm9tKFsyXSkpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzQSAtIEZpcnN0IHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcGFyYW0gYnl0ZXNCIC0gU2Vjb25kIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byB2YWx1ZXMgYXJlIGVxdWFsLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoYnl0ZXNBLCBieXRlc0IpIHtcbiAgICByZXR1cm4gZXF1YWxCeXRlcyhieXRlc0EsIGJ5dGVzQik7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHRoZSBsZWZ0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkTGVmdChCeXRlcy5mcm9tKFsxXSksIDQpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFswLCAwLCAwLCAxXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBTaXplIHRvIHBhZCB0aGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0by5cbiAqIEByZXR1cm5zIFBhZGRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHRoZSByaWdodCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnBhZFJpZ2h0KEJ5dGVzLmZyb20oWzFdKSwgNClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFNpemUgdG8gcGFkIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvLlxuICogQHJldHVybnMgUGFkZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRSaWdodCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAncmlnaHQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJ5dGVzID0gQnl0ZXMucmFuZG9tKDMyKVxuICogLy8gQGxvZzogVWludDhBcnJheShbLi4uIHgzMl0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIC0gTGVuZ3RoIG9mIHRoZSByYW5kb20ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBnZW5lcmF0ZS5cbiAqIEByZXR1cm5zIFJhbmRvbSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKGxlbmd0aCkge1xuICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGxlbmd0aCkpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHNpemUgb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5zaXplKEJ5dGVzLmZyb20oWzEsIDIsIDMsIDRdKSlcbiAqIC8vIEBsb2c6IDRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBTaXplIG9mIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG59XG4vKipcbiAqIFJldHVybnMgYSBzZWN0aW9uIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBnaXZlbiBhIHN0YXJ0L2VuZCBieXRlcyBvZmZzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNsaWNlKFxuICogICBCeXRlcy5mcm9tKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XSksXG4gKiAgIDEsXG4gKiAgIDQsXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsyLCAzLCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHBhcmFtIHN0YXJ0IC0gU3RhcnQgb2Zmc2V0LlxuICogQHBhcmFtIGVuZCAtIEVuZCBvZmZzZXQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNsaWNlIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBTbGljZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCB9ID0gb3B0aW9ucztcbiAgICBpbnRlcm5hbC5hc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpO1xuICAgIGNvbnN0IHZhbHVlXyA9IHZhbHVlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdHJpY3QpXG4gICAgICAgIGludGVybmFsLmFzc2VydEVuZE9mZnNldCh2YWx1ZV8sIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiB2YWx1ZV87XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBiaWdpbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQmlnSW50KEJ5dGVzLmZyb20oWzEsIDE2NF0pKVxuICogLy8gQGxvZzogNDIwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBEZWNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRGVjb2RlZCBiaWdpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ0ludChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgIGNvbnN0IGhleCA9IEhleC5mcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBIZXgudG9CaWdJbnQoaGV4LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQm9vbGVhbihCeXRlcy5mcm9tKFsxXSkpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIERlY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1MZWZ0KGJ5dGVzXyk7XG4gICAgfVxuICAgIGlmIChieXRlc18ubGVuZ3RoID4gMSB8fCBieXRlc19bMF0gPiAxKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yKGJ5dGVzXyk7XG4gICAgcmV0dXJuIEJvb2xlYW4oYnl0ZXNfWzBdKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9IZXgoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBudW1iZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvTnVtYmVyKEJ5dGVzLmZyb20oWzEsIDE2NF0pKVxuICogLy8gQGxvZzogNDIwXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b051bWJlcihoZXgsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMudG9TdHJpbmcoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzXyA9IGJ5dGVzO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlc18sIHNpemUpO1xuICAgICAgICBieXRlc18gPSB0cmltUmlnaHQoYnl0ZXNfKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ5dGVzXyk7XG59XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRyaW1MZWZ0KEJ5dGVzLmZyb20oWzAsIDAsIDAsIDAsIDEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFRyaW1tZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG4vKipcbiAqIFRyaW1zIHRyYWlsaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50cmltUmlnaHQoQnl0ZXMuZnJvbShbMSwgMiwgMywgMCwgMCwgMCwgMF0pKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHJldHVybnMgVHJpbW1lZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAncmlnaHQnIH0pO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnZhbGlkYXRlKCcweCcpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICpcbiAqIEJ5dGVzLnZhbGlkYXRlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIGJ5dGVzIHZhbHVlIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQm9vbGVhbihCeXRlcy5mcm9tKFs1XSkpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcjogQnl0ZXMgdmFsdWUgYFs1XWAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5cbiAqIC8vIEBlcnJvcjogVGhlIGJ5dGVzIGFycmF5IG11c3QgY29udGFpbiBhIHNpbmdsZSBieXRlIG9mIGVpdGhlciBhIGAwYCBvciBgMWAgdmFsdWUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGBCeXRlcyB2YWx1ZSBcXGAke2J5dGVzfVxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb20oJ2ZvbycpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcjogVmFsdWUgYGZvb2Agb2YgdHlwZSBgc3RyaW5nYCBpcyBhbiBpbnZhbGlkIEJ5dGVzIHZhbHVlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0J5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYEJ5dGVzYC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzaXplIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnLCB7IHNpemU6IDggfSlcbiAqIC8vIEBlcnJvcjogQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3I6IFNpemUgY2Fubm90IGV4Y2VlZCBgOGAgYnl0ZXMuIEdpdmVuIHNpemU6IGAxMmAgYnl0ZXMuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgc2xpY2Ugb2Zmc2V0IGlzIG91dC1vZi1ib3VuZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNsaWNlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSwgNClcbiAqIC8vIEBlcnJvcjogQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yOiBTbGljZSBzdGFydGluZyBhdCBvZmZzZXQgYDRgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IGAzYCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0LCBwb3NpdGlvbiwgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2xpY2UgJHtwb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/ICdzdGFydGluZycgOiAnZW5kaW5nJ30gYXQgb2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBcXGAke3NpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHRoZSBwYWRkaW5nIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnBhZExlZnQoQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJyksIDgpXG4gKiAvLyBAZXJyb3I6IFtCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I6IEJ5dGVzIHNpemUgKGAxMmApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChgOGApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpemUsIHRhcmdldFNpemUsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYCR7dHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3R5cGVcbiAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9IHNpemUgKFxcYCR7c2l6ZX1cXGApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChcXGAke3RhcmdldFNpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Ens.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Ens.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   labelhash: () => (/* binding */ labelhash),\n/* harmony export */   namehash: () => (/* binding */ namehash),\n/* harmony export */   normalize: () => (/* binding */ normalize)\n/* harmony export */ });\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/ens.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/ens.js\");\n\n\n\n\n\n/**\n * Hashes ENS label.\n *\n * Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n * ```\n *\n * @param label - ENS label.\n * @returns ENS labelhash.\n */\nfunction labelhash(label) {\n    const result = new Uint8Array(32).fill(0);\n    if (!label)\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    return (_internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(label) || _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(label)));\n}\n/**\n * Hashes ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.namehash('wevm.eth')\n * // @log: '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'\n * ```\n *\n * @param name - ENS name.\n * @returns ENS namehash.\n */\nfunction namehash(name) {\n    let result = new Uint8Array(32).fill(0);\n    if (!name)\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    const labels = name.split('.');\n    // Iterate in reverse order building up hash\n    for (let i = labels.length - 1; i >= 0; i -= 1) {\n        const hashFromEncodedLabel = _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(labels[i]);\n        const hashed = hashFromEncodedLabel\n            ? _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(hashFromEncodedLabel)\n            : _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(labels[i]), { as: 'Bytes' });\n        result = _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.concat(result, hashed), { as: 'Bytes' });\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n}\n/**\n * Normalizes ENS name according to [ENSIP-15](https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md).\n *\n * For more info see [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) on name processing.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.normalize('wevm.eth')\n * // @log: 'wevm.eth'\n * ```\n *\n * @param name - ENS name.\n * @returns Normalized ENS name.\n */\nfunction normalize(name) {\n    return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n}\n//# sourceMappingURL=Ens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RDtBQUNuQjtBQUNGO0FBQ0Y7QUFDYztBQUM5QztBQUNBO0FBQ0E7QUFDQSxzV0FBc1csbUNBQW1DO0FBQ3pZO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsOENBQWE7QUFDNUIsWUFBWSw2REFBd0IsV0FBVywrQ0FBYyxDQUFDLCtDQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbVdBQW1XLG1DQUFtQztBQUN0WTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QyxxQ0FBcUMsNkRBQXdCO0FBQzdEO0FBQ0EsY0FBYyw4Q0FBYTtBQUMzQixjQUFjLCtDQUFjLENBQUMsaURBQWdCLGVBQWUsYUFBYTtBQUN6RSxpQkFBaUIsK0NBQWMsQ0FBQyw2Q0FBWSxvQkFBb0IsYUFBYTtBQUM3RTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxxRUFBYTtBQUN4QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNvbm5lY3RraXQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vucy5qcz8zMjRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tICdAYWRyYWZmeS9lbnMtbm9ybWFsaXplJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvZW5zLmpzJztcbi8qKlxuICogSGFzaGVzIEVOUyBsYWJlbC5cbiAqXG4gKiBTaW5jZSBFTlMgbGFiZWxzIHByb2hpYml0IGNlcnRhaW4gZm9yYmlkZGVuIGNoYXJhY3RlcnMgKGUuZy4gdW5kZXJzY29yZSkgYW5kIGhhdmUgb3RoZXIgdmFsaWRhdGlvbiBydWxlcywgeW91IGxpa2VseSB3YW50IHRvIFtub3JtYWxpemUgRU5TIGxhYmVsc10oaHR0cHM6Ly9kb2NzLmVucy5kb21haW5zL2NvbnRyYWN0LWFwaS1yZWZlcmVuY2UvbmFtZS1wcm9jZXNzaW5nI25vcm1hbGlzaW5nLW5hbWVzKSB3aXRoIFtVVFMtNDYgbm9ybWFsaXphdGlvbl0oaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYpIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gYGxhYmVsaGFzaGAuIFlvdSBjYW4gdXNlIHRoZSBidWlsdC1pbiB7QGxpbmsgb3gjRW5zLihub3JtYWxpemU6ZnVuY3Rpb24pfSBmdW5jdGlvbiBmb3IgdGhpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICogRW5zLmxhYmVsaGFzaCgnZXRoJylcbiAqICcweDRmNWI4MTI3ODlmYzYwNmJlMWIzYjE2OTA4ZGIxM2ZjN2E5YWRmN2NhNzI2NDFmODRkNzViNDcwNjlkM2Q3ZjAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGFiZWwgLSBFTlMgbGFiZWwuXG4gKiBAcmV0dXJucyBFTlMgbGFiZWxoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxoYXNoKGxhYmVsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMCk7XG4gICAgaWYgKCFsYWJlbClcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMocmVzdWx0KTtcbiAgICByZXR1cm4gKGludGVybmFsLnVud3JhcExhYmVsaGFzaChsYWJlbCkgfHwgSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcobGFiZWwpKSk7XG59XG4vKipcbiAqIEhhc2hlcyBFTlMgbmFtZS5cbiAqXG4gKiBTaW5jZSBFTlMgbmFtZXMgcHJvaGliaXQgY2VydGFpbiBmb3JiaWRkZW4gY2hhcmFjdGVycyAoZS5nLiB1bmRlcnNjb3JlKSBhbmQgaGF2ZSBvdGhlciB2YWxpZGF0aW9uIHJ1bGVzLCB5b3UgbGlrZWx5IHdhbnQgdG8gW25vcm1hbGl6ZSBFTlMgbmFtZXNdKGh0dHBzOi8vZG9jcy5lbnMuZG9tYWlucy9jb250cmFjdC1hcGktcmVmZXJlbmNlL25hbWUtcHJvY2Vzc2luZyNub3JtYWxpc2luZy1uYW1lcykgd2l0aCBbVVRTLTQ2IG5vcm1hbGl6YXRpb25dKGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2KSBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIGBuYW1laGFzaGAuIFlvdSBjYW4gdXNlIHRoZSBidWlsdC1pbiB7QGxpbmsgb3gjRW5zLihub3JtYWxpemU6ZnVuY3Rpb24pfSBmdW5jdGlvbiBmb3IgdGhpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICogRW5zLm5hbWVoYXNoKCd3ZXZtLmV0aCcpXG4gKiAvLyBAbG9nOiAnMHhmMjQ2NjUxYzFiOWE2YjE0MWQxOWMyNjA0ZTlhNThmNTY3OTczODMzOTkwZjgzMGQ4ODI1MzRhNzQ3ODAxMzU5J1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBFTlMgbmFtZS5cbiAqIEByZXR1cm5zIEVOUyBuYW1laGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMCk7XG4gICAgaWYgKCFuYW1lKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhyZXN1bHQpO1xuICAgIGNvbnN0IGxhYmVscyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAvLyBJdGVyYXRlIGluIHJldmVyc2Ugb3JkZXIgYnVpbGRpbmcgdXAgaGFzaFxuICAgIGZvciAobGV0IGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3QgaGFzaEZyb21FbmNvZGVkTGFiZWwgPSBpbnRlcm5hbC51bndyYXBMYWJlbGhhc2gobGFiZWxzW2ldKTtcbiAgICAgICAgY29uc3QgaGFzaGVkID0gaGFzaEZyb21FbmNvZGVkTGFiZWxcbiAgICAgICAgICAgID8gQnl0ZXMuZnJvbUhleChoYXNoRnJvbUVuY29kZWRMYWJlbClcbiAgICAgICAgICAgIDogSGFzaC5rZWNjYWsyNTYoQnl0ZXMuZnJvbVN0cmluZyhsYWJlbHNbaV0pLCB7IGFzOiAnQnl0ZXMnIH0pO1xuICAgICAgICByZXN1bHQgPSBIYXNoLmtlY2NhazI1NihCeXRlcy5jb25jYXQocmVzdWx0LCBoYXNoZWQpLCB7IGFzOiAnQnl0ZXMnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhyZXN1bHQpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIEVOUyBuYW1lIGFjY29yZGluZyB0byBbRU5TSVAtMTVdKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNkb21haW5zL2RvY3MvYmxvYi85ZWRmOTQ0M2RlNDMzM2EwZWE3ZWM2NThhODcwNjcyZDVkMTgwZDUzL2Vucy1pbXByb3ZlbWVudC1wcm9wb3NhbHMvZW5zaXAtMTUtbm9ybWFsaXphdGlvbi1zdGFuZGFyZC5tZCkuXG4gKlxuICogRm9yIG1vcmUgaW5mbyBzZWUgW0VOUyBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvY29udHJhY3QtYXBpLXJlZmVyZW5jZS9uYW1lLXByb2Nlc3Npbmcjbm9ybWFsaXNpbmctbmFtZXMpIG9uIG5hbWUgcHJvY2Vzc2luZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICogRW5zLm5vcm1hbGl6ZSgnd2V2bS5ldGgnKVxuICogLy8gQGxvZzogJ3dldm0uZXRoJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBFTlMgbmFtZS5cbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUobmFtZSkge1xuICAgIHJldHVybiBlbnNfbm9ybWFsaXplKG5hbWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW5zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Ens.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/errors.js\");\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nclass BaseError extends Error {\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = 'https://oxlib.sh';\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: `ox@${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()}`\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\n/** @internal */\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtEQUFVLEdBQUc7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNvbm5lY3RraXQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vycm9ycy5qcz8zODA5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFZlcnNpb24gfSBmcm9tICcuL2ludGVybmFsL2Vycm9ycy5qcyc7XG4vKipcbiAqIEJhc2UgZXJyb3IgY2xhc3MgaW5oZXJpdGVkIGJ5IGFsbCBlcnJvcnMgdGhyb3duIGJ5IG94LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRXJyb3JzIH0gZnJvbSAnb3gnXG4gKiB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc2hvcnRNZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlLmRldGFpbHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRldGFpbHM7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2Uuc2hvcnRNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZT8ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGV0YWlscztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgZG9jc1BhdGggPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZG9jc1BhdGggfHwgb3B0aW9ucy5kb2NzUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRvY3NQYXRoO1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBkb2NzQmFzZVVybCA9ICdodHRwczovL294bGliLnNoJztcbiAgICAgICAgY29uc3QgZG9jcyA9IGAke2RvY3NCYXNlVXJsfSR7ZG9jc1BhdGggPz8gJyd9YDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm1ldGFNZXNzYWdlcyA/IFsnJywgLi4ub3B0aW9ucy5tZXRhTWVzc2FnZXNdIDogW10pLFxuICAgICAgICAgICAgLi4uKGRldGFpbHMgfHwgZG9jc1BhdGhcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPyBgRGV0YWlsczogJHtkZXRhaWxzfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGRvY3NQYXRoID8gYFNlZTogJHtkb2NzfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMuY2F1c2UgPyB7IGNhdXNlOiBvcHRpb25zLmNhdXNlIH0gOiB1bmRlZmluZWQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1BhdGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hvcnRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCYXNlRXJyb3InXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBgb3hAJHtnZXRWZXJzaW9uKCl9YFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IG9wdGlvbnMuY2F1c2U7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3M7XG4gICAgICAgIHRoaXMuZG9jc1BhdGggPSBkb2NzUGF0aDtcbiAgICAgICAgdGhpcy5zaG9ydE1lc3NhZ2UgPSBzaG9ydE1lc3NhZ2U7XG4gICAgfVxuICAgIHdhbGsoZm4pIHtcbiAgICAgICAgcmV0dXJuIHdhbGsodGhpcywgZm4pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHdhbGsoZXJyLCBmbikge1xuICAgIGlmIChmbj8uKGVycikpXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgaWYgKGVyciAmJiB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiAnY2F1c2UnIGluIGVyciAmJiBlcnIuY2F1c2UpXG4gICAgICAgIHJldHVybiB3YWxrKGVyci5jYXVzZSwgZm4pO1xuICAgIHJldHVybiBmbiA/IG51bGwgOiBlcnI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hash.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nfunction keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nfunction ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nfunction sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nfunction validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ0o7QUFDTDtBQUMxQjtBQUNKO0FBQ2hDO0FBQ0EsOEVBQThFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0IsOERBQWUsQ0FBQywyQ0FBVTtBQUM1QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0EsK0VBQStFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0Isa0VBQWUsQ0FBQywyQ0FBVTtBQUM1QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0EsNkVBQTZFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0IsNERBQVksQ0FBQywyQ0FBVTtBQUN6QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2Q0FBWSxXQUFXLHlDQUFRO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY29ubmVjdGtpdC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSGFzaC5qcz9hYzM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJpcGVtZDE2MCBhcyBub2JsZV9yaXBlbWQxNjAgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MCc7XG5pbXBvcnQgeyBrZWNjYWtfMjU2IGFzIG5vYmxlX2tlY2NhazI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBzaGEyNTYgYXMgbm9ibGVfc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbS2VjY2FrMjU2XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TSEEtMykgaGFzaCBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSByZS1leHBvcnQgb2YgYGtlY2Nha18yNTZgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogJzB4ZDRmZDRlMTg5MTMyMjczMDM2NDQ5ZmM5ZTExMTk4YzczOTE2MWI0YzAxMTZhOWEyZGNjZGZhMWM0OTIwMDZmMSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ2FsY3VsYXRlIEhhc2ggb2YgYSBTdHJpbmdcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb25maWd1cmUgUmV0dXJuIFR5cGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gua2VjY2FrMjU2KCcweGRlYWRiZWVmJywgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBLZWNjYWsyNTYgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1Nih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBub2JsZV9rZWNjYWsyNTYoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgW1JpcGVtZDE2MF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUklQRU1EKSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBgcmlwZW1kMTYwYCBmcm9tIFtgQG5vYmxlL2hhc2hlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzKSwgYW4gYXVkaXRlZCAmIG1pbmltYWwgSlMgaGFzaGluZyBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gucmlwZW1kMTYwKCcweGRlYWRiZWVmJylcbiAqIC8vICcweDIyNjgyMWMyZjU0MjNlMTFmZTlhZjY4YmQyODVjMjQ5ZGIyZTRiNWEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFJpcGVtZDE2MCBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmlwZW1kMTYwKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX3JpcGVtZDE2MChCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbU2hhMjU2XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TSEEtMjU2KSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBgc2hhMjU2YCBmcm9tIFtgQG5vYmxlL2hhc2hlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzKSwgYW4gYXVkaXRlZCAmIG1pbmltYWwgSlMgaGFzaGluZyBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2guc2hhMjU2KCcweGRlYWRiZWVmJylcbiAqIC8vICcweDVmNzhjMzMyNzRlNDNmYTlkZTU2NTkyNjVjMWQ5MTdlMjVjMDM3MjJkY2IwYjhkMjdkYjhkNWZlYWE4MTM5NTMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFNoYTI1NiBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX3NoYTI1NihCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoYXNoIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gudmFsaWRhdGUoJzB4JylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKlxuICogSGFzaC52YWxpZGF0ZSgnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiBIZXguc2l6ZSh2YWx1ZSkgPT09IDMyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexTypeError: () => (/* binding */ InvalidHexTypeError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   InvalidLengthError: () => (/* binding */ InvalidLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nfunction isEqual(hexA, hexB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexA), _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padLeft(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padRight(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nfunction random(length) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimLeft(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimRight(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nfunction toBoolean(hex, options = {}) {\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nfunction toBytes(hex, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex);\n    if (size) {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__.assertSize(bytes, size);\n        bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nclass IntegerOutOfRangeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nclass InvalidHexBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nclass InvalidHexTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nclass InvalidHexValueError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nclass InvalidLengthError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUN0QjtBQUNFO0FBQ0o7QUFDb0I7QUFDUjtBQUM5QztBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDTztBQUNQLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsNEJBQTRCLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0MseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7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TyxpQ0FBaUMsaURBQWdCO0FBQ3hEO0FBQ0EsOEJBQThCLE1BQU0sd0JBQXdCLGtCQUFrQjtBQUM5RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGlEQUFnQjtBQUN2RCxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNDQUFzQyxRQUFRLDBCQUEwQixVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBDQUEwQyxpREFBZ0I7QUFDakUsa0JBQWtCLHlCQUF5QjtBQUMzQyx1QkFBdUIsOENBQThDLGNBQWMsT0FBTywrQkFBK0IsS0FBSztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsaURBQWdCO0FBQ2pFLGtCQUFrQix5QkFBeUI7QUFDM0MsaUJBQWlCLDZCQUE2QixFQUFFO0FBQ2hEO0FBQ0EsNEJBQTRCLFVBQVUsS0FBSyw4QkFBOEIsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IZXguanM/OWQ5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9ieXRlcyBmcm9tICcuL2ludGVybmFsL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvaGV4LmpzJztcbmNvbnN0IGVuY29kZXIgPSAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgaGV4ZXMgPSAvKiNfX1BVUkVfXyovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBBc3NlcnRzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkSGV4VmFsdWVUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuXG4gKiAvLyBAZXJyb3I6IEhleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4XFwke3N0cmluZ31cImAuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKCEvXjB4WzAtOWEtZkEtRl0qJC8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFZhbHVlRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguY29uY2F0KCcweDEyMycsICcweDQ1NicpXG4gKiAvLyBAbG9nOiAnMHgxMjM0NTYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCguLi52YWx1ZXMpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgucmVwbGFjZSgnMHgnLCAnJyksICcnKX1gO1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgZnJvbSBhIGhleCBzdHJpbmcgb3Ige0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUbyBpbnN0YW50aWF0ZSBmcm9tIGEgKipCb29sZWFuKiosICoqU3RyaW5nKiosIG9yICoqTnVtYmVyKiosIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIGBIZXguZnJvbUJvb2xlYW5gXG4gKlxuICogLSBgSGV4LmZyb21TdHJpbmdgXG4gKlxuICogLSBgSGV4LmZyb21OdW1iZXJgXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb20oJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBIZXguZnJvbShCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKHZhbHVlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4odHJ1ZSlcbiAqIC8vIEBsb2c6ICcweDEnXG4gKlxuICogSGV4LmZyb21Cb29sZWFuKGZhbHNlKVxuICogLy8gQGxvZzogJzB4MCdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBib29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoZXggPSBgMHgke051bWJlcih2YWx1ZSl9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyaW5nICs9IGhleGVzW3ZhbHVlW2ldXTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ31gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZFJpZ2h0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIG51bWJlciBvciBiaWdpbnQgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMClcbiAqIC8vIEBsb2c6ICcweDFhNCdcbiAqXG4gKiBIZXguZnJvbU51bWJlcig0MjAsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIG9yIGJpZ2ludCB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZV8gPSBCaWdJbnQodmFsdWUpO1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2lnbmVkKVxuICAgICAgICAgICAgbWF4VmFsdWUgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuIC0gMW4pKSAtIDFuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXhWYWx1ZSA9IDJuICoqIChCaWdJbnQoc2l6ZSkgKiA4bikgLSAxbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXhWYWx1ZSA9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG4gICAgfVxuICAgIGNvbnN0IG1pblZhbHVlID0gdHlwZW9mIG1heFZhbHVlID09PSAnYmlnaW50JyAmJiBzaWduZWQgPyAtbWF4VmFsdWUgLSAxbiA6IDA7XG4gICAgaWYgKChtYXhWYWx1ZSAmJiB2YWx1ZV8gPiBtYXhWYWx1ZSkgfHwgdmFsdWVfIDwgbWluVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/ICduJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgSW50ZWdlck91dE9mUmFuZ2VFcnJvcih7XG4gICAgICAgICAgICBtYXg6IG1heFZhbHVlID8gYCR7bWF4VmFsdWV9JHtzdWZmaXh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1pbjogYCR7bWluVmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICB2YWx1ZTogYCR7dmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gKHNpZ25lZCAmJiB2YWx1ZV8gPCAwID8gKDFuIDw8IEJpZ0ludChzaXplICogOCkpICsgQmlnSW50KHZhbHVlXykgOiB2YWx1ZV8pLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ1ZhbHVlfWA7XG4gICAgaWYgKHNpemUpXG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgc2l6ZSk7XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJylcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiAzMiB9KVxuICogLy8gJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhlbmNvZGVyLmVuY29kZSh2YWx1ZSksIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmlzRXF1YWwoJzB4ZGVhZGJlZWYnLCAnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogSGV4LmlzRXF1YWwoJzB4ZGEnLCAnMHhiYScpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleEEgLSBUaGUgZmlyc3Qge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIGhleEIgLSBUaGUgc2Vjb25kIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdvIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoaGV4QSwgaGV4Qikge1xuICAgIHJldHVybiBlcXVhbEJ5dGVzKEJ5dGVzLmZyb21IZXgoaGV4QSksIEJ5dGVzLmZyb21IZXgoaGV4QikpO1xufVxuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRoZSBsZWZ0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRMZWZ0KCcweDEyMzQnLCA0KVxuICogLy8gQGxvZzogJzB4MDAwMDEyMzQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgKGluIGJ5dGVzKSBvZiB0aGUgb3V0cHV0IGhleCB2YWx1ZS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdGhlIHJpZ2h0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRSaWdodCgnMHgxMjM0JywgNClcbiAqIC8vIEBsb2c6ICcweDEyMzQwMDAwJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIChpbiBieXRlcykgb2YgdGhlIG91dHB1dCBoZXggdmFsdWUuXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZFJpZ2h0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdyaWdodCcsIHNpemUgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBoZXggPSBIZXgucmFuZG9tKDMyKVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICogYGBgXG4gKlxuICogQHJldHVybnMgUmFuZG9tIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKEJ5dGVzLnJhbmRvbShsZW5ndGgpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGdpdmVuIGEgc3RhcnQvZW5kIGJ5dGVzIG9mZnNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zbGljZSgnMHgwMTIzNDU2Nzg5JywgMSwgNClcbiAqIC8vIEBsb2c6ICcweDIzNDU2NydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gc2xpY2UuXG4gKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnQgb2Zmc2V0IChpbiBieXRlcykuXG4gKiBAcGFyYW0gZW5kIC0gVGhlIGVuZCBvZmZzZXQgKGluIGJ5dGVzKS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzbGljZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gYDB4JHt2YWx1ZVxuICAgICAgICAucmVwbGFjZSgnMHgnLCAnJylcbiAgICAgICAgLnNsaWNlKChzdGFydCA/PyAwKSAqIDIsIChlbmQgPz8gdmFsdWUubGVuZ3RoKSAqIDIpfWA7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIChpbiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2l6ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiA0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgKGluIGJ5dGVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xufVxuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudHJpbUxlZnQoJzB4MDAwMDAwMDBkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiAnMHhkZWFkYmVlZidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdHJpbS5cbiAqIEByZXR1cm5zIFRoZSB0cmltbWVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG4vKipcbiAqIFRyaW1zIHRyYWlsaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudHJpbVJpZ2h0KCcweGRlYWRiZWVmMDAwMDAwMDAnKVxuICogLy8gQGxvZzogJzB4ZGVhZGJlZWYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRyaW0uXG4gKiBAcmV0dXJucyBUaGUgdHJpbW1lZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltUmlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdyaWdodCcgfSk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIEJpZ0ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0JpZ0ludCgnMHgxYTQnKVxuICogLy8gQGxvZzogNDIwblxuICpcbiAqIEhleC50b0JpZ0ludCgnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0JywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogNDIwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgQmlnSW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCB9ID0gb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChoZXgpO1xuICAgIGlmICghc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc2l6ZSA9IChoZXgubGVuZ3RoIC0gMikgLyAyO1xuICAgIGNvbnN0IG1heF91bnNpZ25lZCA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4pKSAtIDFuO1xuICAgIGNvbnN0IG1heF9zaWduZWQgPSBtYXhfdW5zaWduZWQgPj4gMW47XG4gICAgaWYgKHZhbHVlIDw9IG1heF9zaWduZWQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgLSBtYXhfdW5zaWduZWQgLSAxbjtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDEnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCBoZXhfID0gdHJpbUxlZnQoaGV4KTtcbiAgICBpZiAoaGV4XyA9PT0gJzB4JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChoZXhfID09PSAnMHgxJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEludmFsaWRIZXhCb29sZWFuRXJyb3IoaGV4KTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBIZXgudG9CeXRlcygnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgoaGV4LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgbnVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvTnVtYmVyKCcweDFhNCcpXG4gKiAvLyBAbG9nOiA0MjBcbiAqXG4gKiBIZXgudG9OdW1iZXIoJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCcsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IDQyMFxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgbnVtYmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXNpZ25lZCAmJiAhc2l6ZSlcbiAgICAgICAgcmV0dXJuIE51bWJlcihoZXgpO1xuICAgIHJldHVybiBOdW1iZXIodG9CaWdJbnQoaGV4LCBvcHRpb25zKSk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b1N0cmluZygnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJ0hlbGxvIHdvcmxkISdcbiAqXG4gKiBIZXgudG9TdHJpbmcoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIHtcbiAqICBzaXplOiAzMixcbiAqIH0pXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXMgPSBCeXRlcy5mcm9tSGV4KGhleCk7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfYnl0ZXMuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzID0gQnl0ZXMudHJpbVJpZ2h0KGJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC52YWxpZGF0ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogSGV4LnZhbGlkYXRlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEge0BsaW5rIG94I0hleC5IZXh9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSwgeyBzdHJpY3QgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBpbnRlZ2VyIGlzIG91dCBvZiByYW5nZSwgYW5kIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGhleCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMDE4MjczODkxMjczMTI4MzcxMjkzNzEyOSlcbiAqIC8vIEBlcnJvcjogSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3I6IE51bWJlciBcXGA0LjIwMTgyNzM4OTEyNzMxMjZlKzI2XFxgIGlzIG5vdCBpbiBzYWZlIHVuc2lnbmVkIGludGVnZXIgcmFuZ2UgKGAwYCB0byBgOTAwNzE5OTI1NDc0MDk5MWApXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludGVnZXJPdXRPZlJhbmdlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1heCwgbWluLCBzaWduZWQsIHNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBOdW1iZXIgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGluIHNhZmUke3NpemUgPyBgICR7c2l6ZSAqIDh9LWJpdGAgOiAnJ30ke3NpZ25lZCA/ICcgc2lnbmVkJyA6ICcgdW5zaWduZWQnfSBpbnRlZ2VyIHJhbmdlICR7bWF4ID8gYChcXGAke21pbn1cXGAgdG8gXFxgJHttYXh9XFxgKWAgOiBgKGFib3ZlIFxcYCR7bWlufVxcYClgfWApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGhleCB2YWx1ZSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBib29sZWFuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvQm9vbGVhbignMHhhJylcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhCb29sZWFuRXJyb3I6IEhleCB2YWx1ZSBgXCIweGFcImAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5cbiAqIC8vIEBlcnJvcjogVGhlIGhleCB2YWx1ZSBtdXN0IGJlIGBcIjB4MFwiYCAoZmFsc2UpIG9yIGBcIjB4MVwiYCAodHJ1ZSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhCb29sZWFuRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihoZXgpIHtcbiAgICAgICAgc3VwZXIoYEhleCB2YWx1ZSBcXGBcIiR7aGV4fVwiXFxgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBoZXggdmFsdWUgbXVzdCBiZSBgXCIweDBcImAgKGZhbHNlKSBvciBgXCIweDFcImAgKHRydWUpLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoMSlcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhUeXBlRXJyb3I6IFZhbHVlIGAxYCBvZiB0eXBlIGBudW1iZXJgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0hleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4JHtzdHJpbmd9XCJgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoJzB4MDEyMzQ1Njc4OWFiY2RlZmcnKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZEhleFZhbHVlRXJyb3I6IFZhbHVlIGAweDAxMjM0NTY3ODlhYmNkZWZnYCBpcyBhbiBpbnZhbGlkIGhleCB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogSGV4IHZhbHVlcyBtdXN0IHN0YXJ0IHdpdGggYFwiMHhcImAgYW5kIGNvbnRhaW4gb25seSBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzICgwLTksIGEtZiwgQS1GKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEhleFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0hleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhWYWx1ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgaXMgYW4gb2RkIGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuZnJvbUhleCgnMHhhYmNkZScpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkTGVuZ3RoRXJyb3I6IEhleCB2YWx1ZSBgXCIweGFiY2RlXCJgIGlzIGFuIG9kZCBsZW5ndGggKDUgbmliYmxlcykuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRMZW5ndGhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBIZXggdmFsdWUgXFxgXCIke3ZhbHVlfVwiXFxgIGlzIGFuIG9kZCBsZW5ndGggKCR7dmFsdWUubGVuZ3RoIC0gMn0gbmliYmxlcykuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0l0IG11c3QgYmUgYW4gZXZlbiBsZW5ndGguJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRMZW5ndGhFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgdmFsdWUgZXhjZWVkcyB0aGUgZXhwZWN0ZWQgbWF4IHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiA4IH0pXG4gKiAvLyBAZXJyb3I6IEhleC5TaXplT3ZlcmZsb3dFcnJvcjogU2l6ZSBjYW5ub3QgZXhjZWVkIGA4YCBieXRlcy4gR2l2ZW4gc2l6ZTogYDEyYCBieXRlcy5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzbGljZSBvZmZzZXQgZXhjZWVkcyB0aGUgYm91bmRzIG9mIHRoZSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zbGljZSgnMHgwMTIzNDU2Nzg5JywgNilcbiAqIC8vIEBlcnJvcjogSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcjogU2xpY2Ugc3RhcnRpbmcgYXQgb2Zmc2V0IGA2YCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBgNWApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09ICdzdGFydCcgPyAnc3RhcnRpbmcnIDogJ2VuZGluZyd9IGF0IG9mZnNldCBcXGAke29mZnNldH1cXGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogXFxgJHtzaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzaXplIG9mIHRoZSB2YWx1ZSBleGNlZWRzIHRoZSBwYWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRMZWZ0KCcweDFhNGUxMmE0NWEyMTMyMzEyM2FhYTg3YTg5N2E4OTdhODk4YTY1NjdhNTc4YTg2N2E5ODc3OGE2NjdhODVhODc1YTg3YTZhNzg3YTY1YTY3NWE2YTknLCAzMilcbiAqIC8vIEBlcnJvcjogSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjogSGV4IHNpemUgKGA0M2ApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChgMzJgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplLCB0YXJnZXRTaXplLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfSBzaXplIChcXGAke3NpemV9XFxgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoXFxgJHt0YXJnZXRTaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\nconst bigIntSuffix = /*#__PURE__*/ '#__bigint';\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSw2QkFBNkIsZ0ZBQWdGO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLGdGQUFnRjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFLQUFxSztBQUNySztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Kc29uLmpzPzI0ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmlnSW50U3VmZml4ID0gLyojX19QVVJFX18qLyAnI19fYmlnaW50Jztcbi8qKlxuICogUGFyc2VzIGEgSlNPTiBzdHJpbmcsIHdpdGggc3VwcG9ydCBmb3IgYGJpZ2ludGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBKc29uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QganNvbiA9IEpzb24ucGFyc2UoJ3tcImZvb1wiOlwiYmFyXCIsXCJiYXpcIjpcIjY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwI19fYmlnaW50XCJ9JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgZm9vOiAnYmFyJyxcbiAqIC8vIEBsb2c6ICAgYmF6OiA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMG5cbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzdHJpbmcgLSBUaGUgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcGFyYW0gcmV2aXZlciAtIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSByZXN1bHRzLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHN0cmluZywgcmV2aXZlcikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZywgKGtleSwgdmFsdWVfKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVfO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aChiaWdJbnRTdWZmaXgpKVxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZS5zbGljZSgwLCAtYmlnSW50U3VmZml4Lmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyByZXZpdmVyKGtleSwgdmFsdWUpIDogdmFsdWU7XG4gICAgfSk7XG59XG4vKipcbiAqIFN0cmluZ2lmaWVzIGEgdmFsdWUgdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24sIHdpdGggc3VwcG9ydCBmb3IgYGJpZ2ludGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBKc29uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QganNvbiA9IEpzb24uc3RyaW5naWZ5KHtcbiAqICAgZm9vOiAnYmFyJyxcbiAqICAgYmF6OiA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMG4sXG4gKiB9KVxuICogLy8gQGxvZzogJ3tcImZvb1wiOlwiYmFyXCIsXCJiYXpcIjpcIjY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwI19fYmlnaW50XCJ9J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0cmluZ2lmeS5cbiAqIEBwYXJhbSByZXBsYWNlciAtIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSByZXN1bHRzLiBJdCBpcyBwYXNzZWQgdGhlIGtleSBhbmQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LCBhbmQgbXVzdCByZXR1cm4gdGhlIHZhbHVlIHRvIGJlIHVzZWQgaW4gdGhlIEpTT04gc3RyaW5nLiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZSBwcm9wZXJ0eSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBKU09OIHN0cmluZy5cbiAqIEBwYXJhbSBzcGFjZSAtIEEgc3RyaW5nIG9yIG51bWJlciB0aGF0IGRldGVybWluZXMgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBKU09OIHN0cmluZy4gSWYgaXQgaXMgYSBudW1iZXIsIGl0IGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byB1c2UgYXMgaW5kZW50YXRpb247IGlmIGl0IGlzIGEgc3RyaW5nIChlLmcuIGAnXFx0J2ApLCBpdCB1c2VzIHRoZSBzdHJpbmcgYXMgdGhlIGluZGVudGF0aW9uIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRoZSBKU09OIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpICsgYmlnSW50U3VmZml4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgc3BhY2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SnNvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   charCodeMap: () => (/* binding */ charCodeMap),\n/* harmony export */   charCodeToBase16: () => (/* binding */ charCodeToBase16),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n\n/** @internal */\nfunction assertSize(bytes, size_) {\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) > size_)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ3JDO0FBQ087QUFDUCxRQUFRLDJDQUFVO0FBQ2xCLGtCQUFrQix3REFBdUI7QUFDekMsdUJBQXVCLDJDQUFVO0FBQ2pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLDBEQUEwRCwyQ0FBVTtBQUNwRSxrQkFBa0Isa0VBQWlDO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQVU7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLDJDQUFVO0FBQ2xCLGtCQUFrQixrRUFBaUM7QUFDbkQ7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0M7QUFDdkMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQztBQUN4QyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWNvbm5lY3RraXQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzPzljM2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi4vQnl0ZXMuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNpemUoYnl0ZXMsIHNpemVfKSB7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IEJ5dGVzLnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgQnl0ZXMuc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBlbmQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGNoYXJDb2RlTWFwID0ge1xuICAgIHplcm86IDQ4LFxuICAgIG5pbmU6IDU3LFxuICAgIEE6IDY1LFxuICAgIEY6IDcwLFxuICAgIGE6IDk3LFxuICAgIGY6IDEwMixcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLm5pbmUpXG4gICAgICAgIHJldHVybiBjaGFyIC0gY2hhckNvZGVNYXAuemVybztcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuYSAtIDEwKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIGlmIChieXRlcy5sZW5ndGggPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnQnl0ZXMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcGFkZGVkQnl0ZXNbcGFkRW5kID8gaSA6IHNpemUgLSBpIC0gMV0gPVxuICAgICAgICAgICAgYnl0ZXNbcGFkRW5kID8gaSA6IGJ5dGVzLmxlbmd0aCAtIGkgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWU7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/ens.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/ens.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   packetToBytes: () => (/* binding */ packetToBytes),\n/* harmony export */   unwrapLabelhash: () => (/* binding */ unwrapLabelhash),\n/* harmony export */   wrapLabelhash: () => (/* binding */ wrapLabelhash)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Ens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Ens.js */ \"(ssr)/./node_modules/ox/_esm/core/Ens.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * @internal\n * Encodes a [DNS packet](https://docs.ens.domains/resolution/names#dns) into a ByteArray containing a UDP payload.\n */\nfunction packetToBytes(packet) {\n    // strip leading and trailing `.`\n    const value = packet.replace(/^\\.|\\.$/gm, '');\n    if (value.length === 0)\n        return new Uint8Array(1);\n    const bytes = new Uint8Array(_index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(value).byteLength + 2);\n    let offset = 0;\n    const list = value.split('.');\n    for (let i = 0; i < list.length; i++) {\n        let encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(list[i]);\n        // if the length is > 255, make the encoded label value a labelhash\n        // this is compatible with the universal resolver\n        if (encoded.byteLength > 255)\n            encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(wrapLabelhash(_Ens_js__WEBPACK_IMPORTED_MODULE_1__.labelhash(list[i])));\n        bytes[offset] = encoded.length;\n        bytes.set(encoded, offset + 1);\n        offset += encoded.length + 1;\n    }\n    if (bytes.byteLength !== offset + 1)\n        return bytes.slice(0, offset + 1);\n    return bytes;\n}\n/** @internal */\nfunction wrapLabelhash(hash) {\n    return `[${hash.slice(2)}]`;\n}\n/** @internal */\nfunction unwrapLabelhash(label) {\n    if (label.length !== 66)\n        return null;\n    if (label.indexOf('[') !== 0)\n        return null;\n    if (label.indexOf(']') !== 65)\n        return null;\n    const hash = `0x${label.slice(1, 65)}`;\n    if (!_Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(hash, { strict: true }))\n        return null;\n    return hash;\n}\n//# sourceMappingURL=ens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBdUM7QUFDTjtBQUNBO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpREFBZ0I7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsc0JBQXNCLGlEQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQWdCLGVBQWUsOENBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QyxTQUFTLDZDQUFZLFNBQVMsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lbnMuanM/NzFmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCeXRlcyB9IGZyb20gJy4uLy4uL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIEVucyBmcm9tICcuLi9FbnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogRW5jb2RlcyBhIFtETlMgcGFja2V0XShodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvcmVzb2x1dGlvbi9uYW1lcyNkbnMpIGludG8gYSBCeXRlQXJyYXkgY29udGFpbmluZyBhIFVEUCBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFja2V0VG9CeXRlcyhwYWNrZXQpIHtcbiAgICAvLyBzdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBgLmBcbiAgICBjb25zdCB2YWx1ZSA9IHBhY2tldC5yZXBsYWNlKC9eXFwufFxcLiQvZ20sICcnKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShCeXRlcy5mcm9tU3RyaW5nKHZhbHVlKS5ieXRlTGVuZ3RoICsgMik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbGlzdCA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBlbmNvZGVkID0gQnl0ZXMuZnJvbVN0cmluZyhsaXN0W2ldKTtcbiAgICAgICAgLy8gaWYgdGhlIGxlbmd0aCBpcyA+IDI1NSwgbWFrZSB0aGUgZW5jb2RlZCBsYWJlbCB2YWx1ZSBhIGxhYmVsaGFzaFxuICAgICAgICAvLyB0aGlzIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgdW5pdmVyc2FsIHJlc29sdmVyXG4gICAgICAgIGlmIChlbmNvZGVkLmJ5dGVMZW5ndGggPiAyNTUpXG4gICAgICAgICAgICBlbmNvZGVkID0gQnl0ZXMuZnJvbVN0cmluZyh3cmFwTGFiZWxoYXNoKEVucy5sYWJlbGhhc2gobGlzdFtpXSkpKTtcbiAgICAgICAgYnl0ZXNbb2Zmc2V0XSA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgICBieXRlcy5zZXQoZW5jb2RlZCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgIG9mZnNldCArPSBlbmNvZGVkLmxlbmd0aCArIDE7XG4gICAgfVxuICAgIGlmIChieXRlcy5ieXRlTGVuZ3RoICE9PSBvZmZzZXQgKyAxKVxuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgb2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBMYWJlbGhhc2goaGFzaCkge1xuICAgIHJldHVybiBgWyR7aGFzaC5zbGljZSgyKX1dYDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBMYWJlbGhhc2gobGFiZWwpIHtcbiAgICBpZiAobGFiZWwubGVuZ3RoICE9PSA2NilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGxhYmVsLmluZGV4T2YoJ1snKSAhPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGxhYmVsLmluZGV4T2YoJ10nKSAhPT0gNjUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGhhc2ggPSBgMHgke2xhYmVsLnNsaWNlKDEsIDY1KX1gO1xuICAgIGlmICghSGV4LnZhbGlkYXRlKGhhc2gsIHsgc3RyaWN0OiB0cnVlIH0pKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaGFzaDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/ens.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"(ssr)/./node_modules/ox/_esm/core/version.js\");\n\n/** @internal */\nfunction getUrl(url) {\n    return url;\n}\n/** @internal */\nfunction getVersion() {\n    return _version_js__WEBPACK_IMPORTED_MODULE_0__.version;\n}\n/** @internal */\nfunction prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ3hDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsZ0RBQU87QUFDbEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUcsSUFBSSwyQkFBMkIsRUFBRSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lcnJvcnMuanM/MjllZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vdmVyc2lvbi5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKHVybCkge1xuICAgIHJldHVybiB1cmw7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHtcbiAgICByZXR1cm4gdmVyc2lvbjtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV0dHlQcmludChhcmdzKSB7XG4gICAgaWYgKCFhcmdzKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGFyZ3MpXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IGVudHJpZXMucmVkdWNlKChhY2MsIFtrZXldKSA9PiBNYXRoLm1heChhY2MsIGtleS5sZW5ndGgpLCAwKTtcbiAgICByZXR1cm4gZW50cmllc1xuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAgICR7YCR7a2V5fTpgLnBhZEVuZChtYXhMZW5ndGggKyAxKX0gICR7dmFsdWV9YClcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/** @internal */\nfunction assertSize(hex, size_) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex) > size_)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUM7QUFDakM7QUFDTztBQUNQLFFBQVEseUNBQVE7QUFDaEIsa0JBQWtCLHNEQUFxQjtBQUN2Qyx1QkFBdUIseUNBQVE7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsMERBQTBELHlDQUFRO0FBQ2xFLGtCQUFrQixnRUFBK0I7QUFDakQ7QUFDQTtBQUNBLGtCQUFrQix5Q0FBUTtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEseUNBQVE7QUFDaEIsa0JBQWtCLGdFQUErQjtBQUNqRDtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFRO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTywrQkFBK0I7QUFDdEMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ0E7QUFDTyxpQ0FBaUM7QUFDeEMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtY29ubmVjdGtpdC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvaGV4LmpzP2ZjMmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U2l6ZShoZXgsIHNpemVfKSB7XG4gICAgaWYgKEhleC5zaXplKGhleCkgPiBzaXplXylcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEhleC5zaXplKGhleCksXG4gICAgICAgICAgICBtYXhTaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPiAwICYmIHN0YXJ0ID4gSGV4LnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBIZXguc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcGFkKGhleF8sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyLCBzaXplID0gMzIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiBoZXhfO1xuICAgIGNvbnN0IGhleCA9IGhleF8ucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgaWYgKGhleC5sZW5ndGggPiBzaXplICogMilcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnSGV4JyxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGAweCR7aGV4W2RpciA9PT0gJ3JpZ2h0JyA/ICdwYWRFbmQnIDogJ3BhZFN0YXJ0J10oc2l6ZSAqIDIsICcwJyl9YDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciA9ICdsZWZ0JyB9ID0gb3B0aW9ucztcbiAgICBsZXQgZGF0YSA9IHZhbHVlLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIGxldCBzbGljZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtkaXIgPT09ICdsZWZ0JyA/IGkgOiBkYXRhLmxlbmd0aCAtIGkgLSAxXS50b1N0cmluZygpID09PSAnMCcpXG4gICAgICAgICAgICBzbGljZUxlbmd0aCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZGF0YSA9XG4gICAgICAgIGRpciA9PT0gJ2xlZnQnXG4gICAgICAgICAgICA/IGRhdGEuc2xpY2Uoc2xpY2VMZW5ndGgpXG4gICAgICAgICAgICA6IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBzbGljZUxlbmd0aCk7XG4gICAgaWYgKGRhdGEgPT09ICcwJylcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgaWYgKGRpciA9PT0gJ3JpZ2h0JyAmJiBkYXRhLmxlbmd0aCAlIDIgPT09IDEpXG4gICAgICAgIHJldHVybiBgMHgke2RhdGF9MGA7XG4gICAgcmV0dXJuIGAweCR7ZGF0YX1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/** @internal */\nconst version = '0.1.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jb25uZWN0a2l0Ly4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS92ZXJzaW9uLmpzP2FhYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMC4xLjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/version.js\n");

/***/ })

};
;